use crate::{
    expression::{Expression, ExpressionStandard},
    mle::MleIndex,
    FieldExt,
};

// use itertools::Itertools;
use crate::mle::MleRef;
use crate::sumcheck::*;

use ark_std::{cfg_into_iter, cfg_iter};
use itertools::{izip, multizip, Itertools};
use rayon::{
    prelude::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator},
    slice::ParallelSlice,
};
use thiserror::Error;

use super::{Claim, Layer, LayerId};

#[derive(Error, Debug, Clone)]
enum LayerError {
    #[error("The Layer has not finished the sumcheck protocol")]
    SumCheckNotComplete,
    #[error("MLE indices must all be fixed")]
    ClaimMleIndexError,
    #[error("Layer ID not assigned")]
    LayerMleError,
    #[error("MLE within MleRef has multiple values within it")]
    MleRefMleError,
    #[error("Error aggregating claims")]
    ClaimAggroError,
    #[error("Should be evaluating to a sum")]
    ExpressionEvalError,
}

///Take in a layer that has completed the sumcheck protocol and return a list of claims on the next layer
fn get_claims<F: FieldExt>(layer: &impl Layer<F>) -> Result<Vec<(LayerId, Claim<F>)>, LayerError> {
    // First off, parse the expression that is associated with the layer...
    // Next, get to the actual claims that are generated by each expression and grab them
    // Return basically a list of (usize, Claim)
    let layerwise_expr = layer.get_expression();

    // --- Define how to parse the expression tree ---
    // - Basically we just want to go down it and pass up claims
    // - We can only add a new claim if we see an MLE with all its indices bound

    let mut claims: Vec<Claim<F>> = Vec::new();
    let mut indices: Vec<LayerId> = Vec::new();

    let mut observer_fn = |exp: &ExpressionStandard<F>| {
        match exp {
            ExpressionStandard::Mle(mle_ref) => {
                // --- First ensure that all the indices are fixed ---
                let mle_indices = mle_ref.get_mle_indices();

                // --- This is super jank ---
                let mut fixed_mle_indices: Vec<F> = vec![];
                for mle_idx in mle_indices {
                    match mle_idx {
                        // --- We can't have either iterated or indexed bits ---
                        MleIndex::IndexedBit(_) | MleIndex::Iterated => {
                            return Err(LayerError::MleRefMleError);
                        }
                        // --- We can't have either iterated or indexed bits ---
                        MleIndex::Bound(idx) => {
                            fixed_mle_indices.push(*idx);
                        }
                        MleIndex::Fixed(one) => {
                            let idx = if *one { F::from(1_u64) } else { F::from(0_u64) };
                            fixed_mle_indices.push(idx);
                        }
                    }
                }

                // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                let mle_layer_id = match mle_ref.get_layer_id() {
                    None => {
                        return Err(LayerError::LayerMleError);
                    }
                    Some(layer_id) => layer_id,
                };

                // --- Grab the actual value that the claim is supposed to evaluate to ---
                if mle_ref.bookkeeping_table().len() != 1 {
                    return Err(LayerError::MleRefMleError);
                }
                // TODO(ryancao): Does this accidentally take ownership of that element?
                // Answer: No, because F implements Copy
                let claimed_value = mle_ref.bookkeeping_table()[0];

                // --- Construct the claim ---
                let claim: Claim<F> = (fixed_mle_indices, claimed_value);

                // --- Push it into the list of claims ---
                // --- Also push the layer_id ---
                claims.push(claim);
                indices.push(mle_layer_id);
            }
            _ => {}
        }
        Ok(())
    };

    // TODO!(ryancao): What the heck is this code doing?
    let _result = layerwise_expr.traverse(&mut observer_fn);
    if let result = Err(LayerError::ClaimMleIndexError) {
        return result;
    }

    Ok(indices.into_iter().zip(claims).collect())
}

/// Compute evaluations of W(l(x))
fn compute_wlx<F: FieldExt>(
    expr: &mut ExpressionStandard<F>,
    claim_vecs: Vec<Vec<F>>,
    claimed_vals: &mut Vec<F>,
    num_claims: usize,
    num_idx: usize,
    prev_layer_claim: Claim<F>,
) -> Result<Vec<F>, LayerError> {
    //fix variable hella times
    //evaluate expr on the mutated expr

    // get the number of evaluations
    let num_vars = expr.index_mle_indices(0);
    // expr.init_beta_tables(prev_layer_claim);
    let num_evals = (num_vars) * (num_claims) * get_round_degree(&expr, 0);

    // we already have the first #claims evaluations, get the next num_evals - #claims evaluations
    let next_evals: Result<Vec<F>, LayerError> = cfg_into_iter!(num_claims..num_evals)
        .map(|idx| {
            // get the challenge l(idx)
            let new_chal: Vec<F> = cfg_into_iter!(0..num_idx)
                .map(|claim_idx| {
                    let evals: Vec<F> = cfg_into_iter!(&claim_vecs)
                        .map(|claim| claim[claim_idx])
                        .collect();
                    evaluate_at_a_point(evals, F::from(idx as u64)).unwrap()
                })
                .collect();

            // use fix_var to compute W(l(index))
            let fix_expr = expr.clone();
            let mut fixed_expr =
                new_chal
                    .iter()
                    .enumerate()
                    .fold(fix_expr, |mut expr, (idx, chal_point)| {
                        expr.fix_variable(idx, *chal_point);
                        expr
                    });
            let val = compute_sumcheck_message(&mut fixed_expr, 0, 0).unwrap();

            // this has to be a sum--get the overall evaluation
            match val {
                SumOrEvals::Sum(evaluation) => Ok(evaluation),
                SumOrEvals::Evals(_) => Err(LayerError::ExpressionEvalError),
            }
        })
        .collect();

    // concat this with the first k evaluations from the claims to get num_evals evaluations
    claimed_vals.extend(&next_evals.unwrap());
    let wlx_evals = claimed_vals.clone();
    Ok(wlx_evals)
}

/// Aggregate several claims into one
fn aggregate_claims<F: FieldExt>(
    claims: Vec<Claim<F>>,
    expr: &mut ExpressionStandard<F>,
    rchal: F,
    prev_layer_claim: Claim<F>,
) -> Result<Claim<F>, LayerError> {
    let (claim_vecs, mut vals): (Vec<Vec<F>>, Vec<F>) = cfg_into_iter!(claims.clone()).unzip();

    if claims.len() < 1 {
        return Err(LayerError::ClaimAggroError);
    }

    let num_idx = claim_vecs[0].len();

    // get the claim (r* = l(r))
    let rstar: Vec<F> = cfg_into_iter!(0..num_idx)
        .map(|idx| {
            let evals: Vec<F> = cfg_into_iter!(&claim_vecs)
                .map(|claim| claim[idx])
                .collect();
            evaluate_at_a_point(evals, rchal).unwrap()
        })
        .collect();

    // get the evals [W(l(0)), W(l(1)), ...]
    let wlx = compute_wlx(
        expr,
        claim_vecs,
        &mut vals,
        claims.len(),
        num_idx,
        prev_layer_claim,
    )
    .unwrap();

    dbg!(&wlx);
    // interpolate to get W(l(r)), that's the claimed value
    let claimed_val = evaluate_at_a_point(wlx, rchal);

    Ok((rstar, claimed_val.unwrap()))
}

mod test {

    use crate::mle::{dense::DenseMle, Mle};

    use super::*;
    use ark_bn254::Fr;
    use ark_ff::UniformRand;
    use ark_std::test_rng;
    use ark_std::One;

    #[test]
    fn test_get_claim() {
        // [1, 1, 1, 1] \oplus (1 - (1 * (1 + V[1, 1, 1, 1]))) * 2
        let expression1: ExpressionStandard<Fr> = ExpressionStandard::Constant(Fr::one());
        let mle = DenseMle::<_, Fr>::new(vec![Fr::one(), Fr::one(), Fr::one(), Fr::one()]);
        let expression3 = ExpressionStandard::Mle(mle.mle_ref());
        let expression = expression1.clone() + expression3.clone();
        // let expression = expression1.clone() * expression;
        let expression = expression1 - expression;
        let expression = expression * Fr::from(2);
        let _expression = expression3.concat(expression);

        // TODO(ryancao): Need to create a layer and fix all the MLE variables...
    }

    /// Test claim aggregation small mle
    #[test]
    fn test_aggro_claim() {
        let dummy_claim = (vec![Fr::one(); 2], Fr::from(0));

        let mle_v1 = vec![Fr::from(1), Fr::from(0), Fr::from(2), Fr::from(3)];
        let mle1: DenseMle<Fr, Fr> = DenseMle::new(mle_v1);
        let mle_ref = mle1.mle_ref();

        let mut expr = ExpressionStandard::Mle(mle_ref);
        let mut expr_copy = expr.clone();

        let chals1 = vec![Fr::from(3), Fr::from(3)];
        let chals2 = vec![Fr::from(2), Fr::from(7)];
        let chals = vec![&chals1, &chals2];

        let mut valchal: Vec<Fr> = Vec::new();
        for i in 0..2 {
            let mut exp = expr.clone();

            exp.index_mle_indices(0);
            // exp.init_beta_tables(dummy_claim.clone());
            for j in 0..2 {
                exp.fix_variable(j, chals[i][j]);
            }
            let expr_eval = compute_sumcheck_message(&mut exp, 0, 0).unwrap();
            if let SumOrEvals::Sum(num) = expr_eval {
                valchal.push(num);
            }
        }

        dbg!(&valchal);
        let claim1: Claim<Fr> = (chals1, valchal[0]);
        let claim2: Claim<Fr> = (chals2, valchal[1]);

        let res: Claim<Fr> = aggregate_claims(
            vec![claim1, claim2],
            &mut expr,
            Fr::from(10),
            dummy_claim.clone(),
        )
        .unwrap();

        expr_copy.index_mle_indices(0);
        // expr_copy.init_beta_tables(dummy_claim);
        let fix_vars = vec![Fr::from(-7), Fr::from(43)];
        for i in 0..2 {
            expr_copy.fix_variable(i, fix_vars[i]);
        }
        let expr_eval = compute_sumcheck_message(&mut expr_copy, 0, 0).unwrap();

        if let SumOrEvals::Sum(num) = expr_eval {
            let exp: Claim<Fr> = (fix_vars, num);
            assert_eq!(res, exp);
        }
    }

    /// Test claim aggregation on another small mle
    #[test]
    fn test_aggro_claim_2() {
        let dummy_claim = (vec![Fr::one(); 2], Fr::from(0));

        let mle_v1 = vec![Fr::from(1), Fr::from(2), Fr::from(3), Fr::from(4)];
        let mle1: DenseMle<Fr, Fr> = DenseMle::new(mle_v1);
        let mle_ref = mle1.mle_ref();
        let mut expr = ExpressionStandard::Mle(mle_ref);
        let mut expr_copy = expr.clone();

        let chals1 = vec![Fr::from(1), Fr::from(2)];
        let chals2 = vec![Fr::from(2), Fr::from(3)];
        let chals3 = vec![Fr::from(3), Fr::from(1)];
        let chals = vec![&chals1, &chals2, &chals3];
        let mut valchal: Vec<Fr> = Vec::new();

        for i in 0..3 {
            let mut exp = expr.clone();
            exp.index_mle_indices(0);
            // exp.init_beta_tables(dummy_claim.clone());
            for j in 0..2 {
                exp.fix_variable(j, chals[i][j]);
            }
            let expr_eval = compute_sumcheck_message(&mut exp, 0, 0).unwrap();
            if let SumOrEvals::Sum(num) = expr_eval {
                valchal.push(num);
            }
        }

        let claim1: Claim<Fr> = (chals1, valchal[0]);
        let claim2: Claim<Fr> = (chals2, valchal[1]);
        let claim3: Claim<Fr> = (chals3, valchal[2]);

        let rchal = Fr::from(-2);

        let res: Claim<Fr> = aggregate_claims(
            vec![claim1, claim2, claim3],
            &mut expr,
            rchal,
            dummy_claim.clone(),
        )
        .unwrap();

        let transpose1 = vec![Fr::from(1), Fr::from(2), Fr::from(3)];
        let transpose2 = vec![Fr::from(2), Fr::from(3), Fr::from(1)];

        let fix_vars: Vec<Fr> = vec![transpose1, transpose2]
            .into_iter()
            .map(|evals| evaluate_at_a_point(evals, rchal).unwrap())
            .collect();

        expr_copy.index_mle_indices(0);
        // expr_copy.init_beta_tables(dummy_claim);
        for i in 0..2 {
            expr_copy.fix_variable(i, fix_vars[i]);
        }
        let expr_eval = compute_sumcheck_message(&mut expr_copy, 0, 0).unwrap();
        if let SumOrEvals::Sum(num) = expr_eval {
            let exp: Claim<Fr> = (fix_vars, num);
            assert_eq!(res, exp);
        }
    }

    /// Test claim aggregation on random mle
    #[test]
    fn test_aggro_claim_3() {
        let dummy_claim = (vec![Fr::one(); 3], Fr::from(0));
        let mut rng = test_rng();
        let mle_v1 = vec![
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
        ];
        let mle1: DenseMle<Fr, Fr> = DenseMle::new(mle_v1);
        let mle_ref = mle1.mle_ref();
        let mut expr = ExpressionStandard::Mle(mle_ref);
        let mut expr_copy = expr.clone();

        let chals1 = vec![Fr::from(-2), Fr::from(-192013), Fr::from(2148)];
        let chals2 = vec![Fr::from(123), Fr::from(482), Fr::from(241)];
        let chals3 = vec![Fr::from(92108), Fr::from(29014), Fr::from(524)];
        let chals = vec![&chals1, &chals2, &chals3];
        let mut valchal: Vec<Fr> = Vec::new();
        for i in 0..3 {
            let mut exp = expr.clone();
            exp.index_mle_indices(0);
            // exp.init_beta_tables(dummy_claim.clone());
            for j in 0..3 {
                exp.fix_variable(j, chals[i][j]);
            }
            let expr_eval = compute_sumcheck_message(&mut exp, 0, 0).unwrap();
            if let SumOrEvals::Sum(num) = expr_eval {
                valchal.push(num);
            }
        }

        let claim1: Claim<Fr> = (chals1, valchal[0]);
        let claim2: Claim<Fr> = (chals2, valchal[1]);
        let claim3: Claim<Fr> = (chals3, valchal[2]);

        let rchal = Fr::rand(&mut rng);

        let res: Claim<Fr> = aggregate_claims(
            vec![claim1, claim2, claim3],
            &mut expr,
            rchal,
            dummy_claim.clone(),
        )
        .unwrap();

        let transpose1 = vec![Fr::from(-2), Fr::from(123), Fr::from(92108)];
        let transpose2 = vec![Fr::from(-192013), Fr::from(482), Fr::from(29014)];
        let transpose3 = vec![Fr::from(2148), Fr::from(241), Fr::from(524)];

        let fix_vars: Vec<Fr> = vec![transpose1, transpose2, transpose3]
            .into_iter()
            .map(|evals| evaluate_at_a_point(evals, rchal).unwrap())
            .collect();

        expr_copy.index_mle_indices(0);
        // expr_copy.init_beta_tables(dummy_claim);
        for i in 0..3 {
            expr_copy.fix_variable(i, fix_vars[i]);
        }
        let expr_eval = compute_sumcheck_message(&mut expr_copy, 0, 0).unwrap();
        if let SumOrEvals::Sum(num) = expr_eval {
            let exp: Claim<Fr> = (fix_vars, num);
            assert_eq!(res, exp);
        }
    }

    /// Test claim aggregation on a RANDOM mle
    #[test]
    fn test_aggro_claim_4() {
        let dummy_claim = (vec![Fr::from(1); 3], Fr::from(0));
        let mut rng = test_rng();
        let mle_v1 = vec![Fr::rand(&mut rng), Fr::rand(&mut rng)];
        let mle_v2 = vec![
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
        ];
        let mle1: DenseMle<Fr, Fr> = DenseMle::new(mle_v1);
        let mle2: DenseMle<Fr, Fr> = DenseMle::new(mle_v2);
        let mle_ref = mle1.mle_ref();
        let mle_ref2 = mle2.mle_ref();

        let mut expr = ExpressionStandard::Product(vec![mle_ref, mle_ref2]);
        let mut expr_copy = expr.clone();

        let chals1 = vec![Fr::from(-2), Fr::from(-192013), Fr::from(2148)];
        let chals2 = vec![Fr::from(123), Fr::from(482), Fr::from(241)];
        let chals3 = vec![Fr::from(92108), Fr::from(29014), Fr::from(524)];
        let chals = vec![&chals1, &chals2, &chals3];
        let mut valchal: Vec<Fr> = Vec::new();
        for i in 0..3 {
            let mut exp = expr.clone();
            exp.index_mle_indices(0);
            // exp.init_beta_tables(dummy_claim.clone());
            for j in 0..3 {
                exp.fix_variable(j, chals[i][j]);
            }
            let expr_eval = compute_sumcheck_message(&mut exp, 0, 0).unwrap();
            if let SumOrEvals::Sum(num) = expr_eval {
                valchal.push(num);
            }
        }

        let claim1: Claim<Fr> = (chals1, valchal[0]);
        let claim2: Claim<Fr> = (chals2, valchal[1]);
        let claim3: Claim<Fr> = (chals3, valchal[2] + Fr::one());

        let rchal = Fr::rand(&mut rng);

        let res: Claim<Fr> = aggregate_claims(
            vec![claim1, claim2, claim3],
            &mut expr,
            rchal,
            dummy_claim.clone(),
        )
        .unwrap();

        let transpose1 = vec![Fr::from(-2), Fr::from(123), Fr::from(92108)];
        let transpose2 = vec![Fr::from(-192013), Fr::from(482), Fr::from(29014)];
        let transpose3 = vec![Fr::from(2148), Fr::from(241), Fr::from(524)];

        let fix_vars: Vec<Fr> = vec![transpose1, transpose2, transpose3]
            .into_iter()
            .map(|evals| evaluate_at_a_point(evals, rchal).unwrap())
            .collect();

        expr_copy.index_mle_indices(0);
        // expr_copy.init_beta_tables(dummy_claim);
        for i in 0..3 {
            expr_copy.fix_variable(i, fix_vars[i]);
        }
        let expr_eval = compute_sumcheck_message(&mut expr_copy, 0, 0).unwrap();
        if let SumOrEvals::Sum(num) = expr_eval {
            let exp: Claim<Fr> = (fix_vars, num);
            assert_ne!(res, exp);
        }
    }

    /// Make sure claim aggregation FAILS for a WRONG CLAIM!
    #[test]
    fn test_aggro_claim_negative_1() {
        let dummy_claim = (vec![Fr::from(1); 3], Fr::from(0));
        let mut rng = test_rng();
        let mle_v1 = vec![
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
        ];
        let mle1: DenseMle<Fr, Fr> = DenseMle::new(mle_v1);
        let mle_ref = mle1.mle_ref();
        let mut expr = ExpressionStandard::Mle(mle_ref);
        let mut expr_copy = expr.clone();

        let chals1 = vec![Fr::from(-2), Fr::from(-192013), Fr::from(2148)];
        let chals2 = vec![Fr::from(123), Fr::from(482), Fr::from(241)];
        let chals3 = vec![Fr::from(92108), Fr::from(29014), Fr::from(524)];
        let chals = vec![&chals1, &chals2, &chals3];
        let mut valchal: Vec<Fr> = Vec::new();
        for i in 0..3 {
            let mut exp = expr.clone();
            exp.index_mle_indices(0);
            // exp.init_beta_tables(dummy_claim.clone());
            for j in 0..3 {
                exp.fix_variable(j, chals[i][j]);
            }
            let expr_eval = compute_sumcheck_message(&mut exp, 0, 0).unwrap();
            if let SumOrEvals::Sum(num) = expr_eval {
                valchal.push(num);
            }
        }

        let claim1: Claim<Fr> = (chals1, valchal[0] - Fr::one());
        let claim2: Claim<Fr> = (chals2, valchal[1]);
        let claim3: Claim<Fr> = (chals3, valchal[2]);

        let rchal = Fr::rand(&mut rng);

        let res: Claim<Fr> = aggregate_claims(
            vec![claim1, claim2, claim3],
            &mut expr,
            rchal,
            dummy_claim.clone(),
        )
        .unwrap();

        let transpose1 = vec![Fr::from(-2), Fr::from(123), Fr::from(92108)];
        let transpose2 = vec![Fr::from(-192013), Fr::from(482), Fr::from(29014)];
        let transpose3 = vec![Fr::from(2148), Fr::from(241), Fr::from(524)];

        let fix_vars: Vec<Fr> = vec![transpose1, transpose2, transpose3]
            .into_iter()
            .map(|evals| evaluate_at_a_point(evals, rchal).unwrap())
            .collect();

        expr_copy.index_mle_indices(0);
        // expr_copy.init_beta_tables(dummy_claim);
        for i in 0..3 {
            expr_copy.fix_variable(i, fix_vars[i]);
        }
        let expr_eval = compute_sumcheck_message(&mut expr_copy, 0, 0).unwrap();
        if let SumOrEvals::Sum(num) = expr_eval {
            let exp: Claim<Fr> = (fix_vars, num);
            assert_ne!(res, exp);
        }
    }

    /// Make sure claim aggregation fails for ANOTHER WRONG CLAIM!
    #[test]
    fn test_aggro_claim_negative_2() {
        let dummy_claim = (vec![Fr::from(1); 3], Fr::from(0));
        let mut rng = test_rng();
        let mle_v1 = vec![
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
            Fr::rand(&mut rng),
        ];
        let mle1: DenseMle<Fr, Fr> = DenseMle::new(mle_v1);
        let mle_ref = mle1.mle_ref();
        let mut expr = ExpressionStandard::Mle(mle_ref);
        let mut expr_copy = expr.clone();

        let chals1 = vec![Fr::from(-2), Fr::from(-192013), Fr::from(2148)];
        let chals2 = vec![Fr::from(123), Fr::from(482), Fr::from(241)];
        let chals3 = vec![Fr::from(92108), Fr::from(29014), Fr::from(524)];
        let chals = vec![&chals1, &chals2, &chals3];
        let mut valchal: Vec<Fr> = Vec::new();
        for i in 0..3 {
            let mut exp = expr.clone();
            exp.index_mle_indices(0);
            // exp.init_beta_tables(dummy_claim.clone());
            for j in 0..3 {
                exp.fix_variable(j, chals[i][j]);
            }
            let expr_eval = compute_sumcheck_message(&mut exp, 0, 0).unwrap();
            if let SumOrEvals::Sum(num) = expr_eval {
                valchal.push(num);
            }
        }

        let claim1: Claim<Fr> = (chals1, valchal[0]);
        let claim2: Claim<Fr> = (chals2, valchal[1]);
        let claim3: Claim<Fr> = (chals3, valchal[2] + Fr::one());

        let rchal = Fr::rand(&mut rng);

        let res: Claim<Fr> = aggregate_claims(
            vec![claim1, claim2, claim3],
            &mut expr,
            rchal,
            dummy_claim.clone(),
        )
        .unwrap();

        let transpose1 = vec![Fr::from(-2), Fr::from(123), Fr::from(92108)];
        let transpose2 = vec![Fr::from(-192013), Fr::from(482), Fr::from(29014)];
        let transpose3 = vec![Fr::from(2148), Fr::from(241), Fr::from(524)];

        let fix_vars: Vec<Fr> = vec![transpose1, transpose2, transpose3]
            .into_iter()
            .map(|evals| evaluate_at_a_point(evals, rchal).unwrap())
            .collect();

        expr_copy.index_mle_indices(0);
        // expr_copy.init_beta_tables(dummy_claim);
        for i in 0..3 {
            expr_copy.fix_variable(i, fix_vars[i]);
        }
        let expr_eval = compute_sumcheck_message(&mut expr_copy, 0, 0).unwrap();
        if let SumOrEvals::Sum(num) = expr_eval {
            let exp: Claim<Fr> = (fix_vars, num);
            assert_ne!(res, exp);
        }
    }
}
